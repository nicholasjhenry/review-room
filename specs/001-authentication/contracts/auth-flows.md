# Authentication Flows & Routes

**Feature**: 001-authentication
**Date**: 2025-10-20
**Phase**: 1 (Design & Contracts)

## Overview

This document describes the authentication routes, flows, and contracts generated by `mix phx.gen.auth Accounts User users --live`. All routes use LiveView for a seamless user experience.

---

## Routes

### Public Routes (Unauthenticated)

| Method | Path | LiveView/Controller | Purpose |
|--------|------|---------------------|---------|
| GET | `/users/register` | `UserRegistrationLive` | Display registration form |
| POST | `/users/register` | `UserRegistrationLive` | Handle registration submission |
| GET | `/users/log_in` | `UserLoginLive` | Display login form |
| POST | `/users/log_in` | `UserLoginLive` | Handle login submission |
| GET | `/users/reset_password` | `UserResetPasswordLive` | Request password reset |
| POST | `/users/reset_password` | `UserResetPasswordLive` | Send reset email |
| GET | `/users/reset_password/:token` | `UserResetPasswordLive` | Reset password with token |
| PUT | `/users/reset_password/:token` | `UserResetPasswordLive` | Submit new password |
| GET | `/users/confirm` | `UserConfirmationLive` | Resend confirmation email |
| POST | `/users/confirm` | `UserConfirmationLive` | Request new confirmation |
| GET | `/users/confirm/:token` | `UserConfirmationLive` | Confirm email address |

### Protected Routes (Authenticated)

| Method | Path | LiveView/Controller | Purpose |
|--------|------|---------------------|---------|
| GET | `/users/settings` | `UserSettingsLive` | User account settings |
| PUT | `/users/settings` | `UserSettingsLive` | Update email |
| PUT | `/users/settings/update_password` | `UserSettingsLive` | Update password |
| GET | `/users/settings/confirm_email/:token` | `UserSettingsLive` | Confirm new email |
| DELETE | `/users/log_out` | `UserSessionController` | Log out current session |

---

## Flow 1: User Registration

**User Story**: US1 - User Registration (Priority P1)

**Flow Diagram**:
```
[User] → GET /users/register → [Registration Form]
           ↓
       [Fill email + password]
           ↓
       POST /users/register
           ↓
    [Accounts.register_user]
           ↓
    [Generate confirm token]
           ↓
    [Send confirmation email]
           ↓
    [Redirect to login with message]
           ↓
[User checks email (terminal log)]
           ↓
  GET /users/confirm/:token
           ↓
  [Accounts.confirm_user]
           ↓
  [Create session token]
           ↓
  [Redirect to /] (logged in)
```

**Contract: POST /users/register**

**Request** (LiveView form submission):
```elixir
# Form params
%{
  "user" => %{
    "email" => "user@example.com",
    "password" => "securepassword123"
  }
}
```

**Validation**:
- Email: required, format: `[^@\s]+@[^@\s]+`, unique, max 160 chars
- Password: required, min 12 chars, max 72 chars

**Success Response** (HTTP 302):
```elixir
# Redirect to login page
redirect(to: ~p"/users/log_in")

# Flash message
put_flash(:info, "User created successfully. Please check your email to confirm your account.")
```

**Error Response** (HTTP 200 re-render):
```elixir
# Re-render form with errors
%{
  errors: [
    email: {"has already been taken", []},
    password: {"should be at least 12 character(s)", [count: 12]}
  ]
}
```

**Side Effects**:
1. User record created in database
2. Confirmation token generated and stored
3. Confirmation email logged to terminal
4. Email contains link: `/users/confirm/:token`

---

## Flow 2: User Login

**User Story**: US2 - User Login (Priority P1)

**Flow Diagram**:
```
[User] → GET /users/log_in → [Login Form]
           ↓
  [Fill email + password + remember_me]
           ↓
       POST /users/log_in
           ↓
[Accounts.get_user_by_email_and_password]
           ↓
    [Verify user confirmed]
           ↓
   [Generate session token]
           ↓
   [Store token in cookie]
           ↓
   [Redirect to /] (logged in)
```

**Contract: POST /users/log_in**

**Request** (LiveView form submission):
```elixir
# Form params
%{
  "user" => %{
    "email" => "user@example.com",
    "password" => "securepassword123",
    "remember_me" => "true"  # optional, defaults to false
  }
}
```

**Success Response** (HTTP 302):
```elixir
# Redirect to home page
redirect(to: ~p"/")

# Session cookie set
conn
|> put_session(:user_token, token)
|> put_session(:live_socket_id, "users_sessions:#{Base.url_encode64(token)}")

# Remember me: max_age = 5,184,000 seconds (60 days)
# Default: session cookie (expires on browser close)
```

**Error Response** (HTTP 200 re-render):
```elixir
# Re-render with generic error (prevent enumeration)
put_flash(:error, "Invalid email or password")
```

**Unconfirmed User Response** (HTTP 302):
```elixir
# Redirect to resend confirmation
redirect(to: ~p"/users/confirm")
put_flash(:error, "You must confirm your account before logging in.")
```

**Side Effects**:
1. Session token created in database
2. User session established (cookie set)
3. LiveView socket authenticated
4. `@current_user` available in all LiveViews

---

## Flow 3: User Logout

**User Story**: US3 - User Logout (Priority P1)

**Flow Diagram**:
```
[User] → DELETE /users/log_out
           ↓
  [Get token from session]
           ↓
[Accounts.delete_session_token]
           ↓
  [Clear session cookie]
           ↓
   [Redirect to /]
```

**Contract: DELETE /users/log_out**

**Request**:
```elixir
# No body, token from session cookie
delete(conn, ~p"/users/log_out")
```

**Response** (HTTP 302):
```elixir
# Redirect to home
redirect(to: ~p"/")

# Flash message
put_flash(:info, "Logged out successfully.")

# Session cleared
conn
|> delete_session(:user_token)
|> delete_session(:live_socket_id)
```

**Side Effects**:
1. Session token deleted from database
2. Session cookie cleared
3. `@current_user` becomes nil

---

## Flow 4: Password Reset

**User Story**: US4 - Password Reset (Priority P2)

**Flow Diagram**:
```
[User] → GET /users/reset_password → [Request Form]
           ↓
       [Enter email]
           ↓
   POST /users/reset_password
           ↓
[Accounts.deliver_user_reset_password_instructions]
           ↓
   [Generate reset token]
           ↓
   [Send reset email]
           ↓
[Generic success message] (prevent enumeration)
           ↓
[User checks email (terminal log)]
           ↓
GET /users/reset_password/:token → [Reset Form]
           ↓
   [Enter new password]
           ↓
PUT /users/reset_password/:token
           ↓
[Accounts.reset_user_password]
           ↓
   [Delete reset token]
           ↓
   [Hash new password]
           ↓
   [Update user record]
           ↓
   [Create session token]
           ↓
   [Redirect to /] (logged in)
```

**Contract: POST /users/reset_password**

**Request**:
```elixir
%{
  "user" => %{
    "email" => "user@example.com"
  }
}
```

**Response** (HTTP 200):
```elixir
# Always success to prevent email enumeration
put_flash(:info, "If your email is in our system, you will receive instructions to reset your password shortly.")
```

**Side Effects** (if email exists):
1. Reset token generated and stored (1 day expiration)
2. Reset email logged to terminal
3. Email contains link: `/users/reset_password/:token`

**Contract: PUT /users/reset_password/:token**

**Request**:
```elixir
%{
  "user" => %{
    "password" => "newsecurepassword123",
    "password_confirmation" => "newsecurepassword123"
  }
}
```

**Success Response** (HTTP 302):
```elixir
# Redirect to home (logged in)
redirect(to: ~p"/")
put_flash(:info, "Password reset successfully.")
```

**Error Response** (HTTP 200):
```elixir
# Invalid or expired token
put_flash(:error, "Reset password link is invalid or it has expired.")

# Validation errors
%{errors: [password: {"should be at least 12 character(s)", []}]}
```

**Side Effects**:
1. Password updated in database
2. Reset token deleted (single-use)
3. All previous reset tokens invalidated
4. Session token created (user logged in)

---

## Flow 5: Email Change

**User Story**: US5 - Email Change (Priority P2)

**Flow Diagram**:
```
[User logged in] → GET /users/settings → [Settings Page]
           ↓
  [Enter new email + current password]
           ↓
   PUT /users/settings
           ↓
[Accounts.apply_user_email]
           ↓
  [Validate email format/uniqueness]
           ↓
  [Verify current password]
           ↓
[Generate email change token]
           ↓
[Send confirmation to NEW email]
           ↓
[Success message]
           ↓
[User checks new email (terminal log)]
           ↓
GET /users/settings/confirm_email/:token
           ↓
[Accounts.update_user_email]
           ↓
  [Update email in database]
           ↓
  [Delete token]
           ↓
  [Redirect to /users/settings]
```

**Contract: PUT /users/settings (email)**

**Request**:
```elixir
%{
  "action" => "update_email",
  "current_password" => "securepassword123",
  "user" => %{
    "email" => "newemail@example.com"
  }
}
```

**Success Response** (HTTP 200):
```elixir
put_flash(:info, "A link to confirm your email change has been sent to the new address.")
```

**Error Response** (HTTP 200):
```elixir
# Invalid password
put_flash(:error, "Current password is invalid")

# Email taken
%{errors: [email: {"has already been taken", []}]}
```

**Side Effects**:
1. Email change token generated (1 day expiration)
2. Confirmation email sent to NEW email address
3. Email change NOT applied until confirmation

---

## Flow 6: Password Change

**User Story**: US6 - Password Change (Priority P2)

**Flow Diagram**:
```
[User logged in] → GET /users/settings → [Settings Page]
           ↓
  [Enter current + new password]
           ↓
PUT /users/settings/update_password
           ↓
[Accounts.update_user_password]
           ↓
  [Verify current password]
           ↓
  [Validate new password]
           ↓
  [Hash new password]
           ↓
  [Update database]
           ↓
  [Success message]
```

**Contract: PUT /users/settings/update_password**

**Request**:
```elixir
%{
  "action" => "update_password",
  "current_password" => "securepassword123",
  "user" => %{
    "password" => "newsecurepassword456",
    "password_confirmation" => "newsecurepassword456"
  }
}
```

**Success Response** (HTTP 200):
```elixir
put_flash(:info, "Password updated successfully.")
```

**Error Response** (HTTP 200):
```elixir
# Wrong current password
put_flash(:error, "Current password is invalid")

# Validation errors
%{errors: [password: {"should be at least 12 character(s)", []}]}
```

**Side Effects**:
1. Password updated in database
2. User remains logged in (session not invalidated)

---

## Authentication Hooks (LiveView)

### :on_mount Hooks

**Generated hooks**: `lib/review_room_web/user_auth.ex`

**1. :mount_current_user**
- Loads `@current_user` assign for all LiveViews
- Checks session token from cookie
- Sets `@current_user = nil` if not authenticated

**Usage**:
```elixir
live_session :default, on_mount: [{ReviewRoomWeb.UserAuth, :mount_current_user}] do
  live "/", HomeLive
  # Other public LiveViews
end
```

**2. :ensure_authenticated**
- Requires user to be logged in
- Redirects to `/users/log_in` if not authenticated
- Stores return_to path for redirect after login

**Usage**:
```elixir
live_session :authenticated,
  on_mount: [
    {ReviewRoomWeb.UserAuth, :mount_current_user},
    {ReviewRoomWeb.UserAuth, :ensure_authenticated}
  ] do
  live "/users/settings", UserSettingsLive
  # Other protected LiveViews
end
```

**3. :redirect_if_user_is_authenticated**
- Prevents logged-in users from accessing auth pages
- Redirects to `/` if already authenticated

**Usage**:
```elixir
live_session :public,
  on_mount: [
    {ReviewRoomWeb.UserAuth, :mount_current_user},
    {ReviewRoomWeb.UserAuth, :redirect_if_user_is_authenticated}
  ] do
  live "/users/register", UserRegistrationLive
  live "/users/log_in", UserLoginLive
end
```

---

## Session Management

### Session Token Storage

**Cookie Name**: `_review_room_web_user_session`

**Token Attributes**:
- Cryptographically random (32 bytes)
- Hashed in database (SHA-256)
- Plaintext in cookie (secure, httponly flags)

**Expiration**:
- Remember me: 60 days
- Default: Session cookie (browser close)

### Token Validation

**On each request**:
1. Read token from session cookie
2. Hash token with SHA-256
3. Query database for matching UserToken
4. Check `inserted_at` for expiration
5. Load associated User
6. Set `@current_user` assign

**Performance**: Single indexed database query per request

---

## Error Handling

### Common Error Scenarios

| Scenario | HTTP Code | Response | Flash Message |
|----------|-----------|----------|---------------|
| Invalid email format | 200 | Re-render form | Field validation error |
| Email already taken | 200 | Re-render form | "Email has already been taken" |
| Password too short | 200 | Re-render form | "Password should be at least 12 character(s)" |
| Invalid credentials | 200 | Re-render form | "Invalid email or password" |
| Unconfirmed account | 302 | Redirect to confirm | "You must confirm your account" |
| Invalid token | 302 | Redirect to request new | "Link is invalid or expired" |
| Not authenticated | 302 | Redirect to login | "You must log in to access this page" |

### Security Considerations

1. **Email Enumeration Prevention**: Password reset always returns success
2. **Timing Attack Prevention**: Bcrypt.verify_pass uses constant-time comparison
3. **Token Hashing**: All tokens hashed before storage
4. **CSRF Protection**: Automatic via Phoenix form tokens
5. **Password Constraints**: 12-72 characters (bcrypt limitation)

---

## Summary

**Total Routes**: 16 (11 GET, 5 POST/PUT/DELETE)
**LiveViews**: 6 (Registration, Login, ResetPassword, Confirmation, Settings)
**Controllers**: 1 (UserSessionController for logout)
**Hooks**: 3 (:mount_current_user, :ensure_authenticated, :redirect_if_authenticated)
**Flows**: 6 (Register, Login, Logout, Reset Password, Email Change, Password Change)

All routes and flows are generated by `mix phx.gen.auth Accounts User users --live`.
