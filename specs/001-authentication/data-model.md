# Data Model: User Authentication System

**Feature**: 001-authentication
**Date**: 2025-10-20
**Phase**: 1 (Design & Contracts)

## Overview

Data model for the authentication system generated by `mix phx.gen.auth`. This document describes the entities, relationships, and validation rules that will be created by the Phoenix generator.

## Entity Relationship Diagram

```
┌─────────────────────────┐
│       User              │
│─────────────────────────│
│ id (PK, UUID)           │
│ email (unique)          │
│ hashed_password         │
│ confirmed_at (nullable) │
│ inserted_at             │
│ updated_at              │
└─────────────────────────┘
           │
           │ has_many
           │
           ▼
┌─────────────────────────┐
│    UserToken            │
│─────────────────────────│
│ id (PK, UUID)           │
│ user_id (FK)            │
│ token (hashed, binary)  │
│ context (string)        │
│ sent_to (string)        │
│ inserted_at             │
└─────────────────────────┘
```

## Entities

### User

**Purpose**: Represents an authenticated user account in the system.

**Schema**: `ReviewRoom.Accounts.User`

**Table**: `users`

**Fields**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | `:binary_id` (UUID) | Primary key, default: `Ecto.UUID.generate/0` | Unique user identifier |
| `email` | `:string` | NOT NULL, UNIQUE | User's email address for login and communication |
| `hashed_password` | `:string` | NOT NULL | Bcrypt/Pbkdf2 hashed password (never store plaintext) |
| `confirmed_at` | `:naive_datetime` | NULL allowed | Timestamp when email was confirmed; NULL = unconfirmed |
| `inserted_at` | `:naive_datetime` | NOT NULL, auto | Account creation timestamp |
| `updated_at` | `:naive_datetime` | NOT NULL, auto | Last account modification timestamp |

**Virtual Fields** (not persisted):
- `password` - Plain text password during registration/change (never saved)
- `current_password` - Used for password change verification (never saved)

**Indexes**:
- Unique index on `email` (enforces uniqueness, speeds up lookups)

**Relationships**:
- `has_many :tokens, ReviewRoom.Accounts.UserToken` - All tokens belonging to this user

**Validations**:

```elixir
# Registration changeset
def registration_changeset(user, attrs, opts \\ []) do
  user
  |> cast(attrs, [:email, :password])
  |> validate_email()
  |> validate_password(opts)
end

# Email validation
defp validate_email(changeset) do
  changeset
  |> validate_required([:email])
  |> validate_format(:email, ~r/^[^\s]+@[^\s]+$/, message: "must have the @ sign and no spaces")
  |> validate_length(:email, max: 160)
  |> unsafe_validate_unique(:email, ReviewRoom.Repo)
  |> unique_constraint(:email)
end

# Password validation
defp validate_password(changeset, opts) do
  changeset
  |> validate_required([:password])
  |> validate_length(:password, min: 12, max: 72)
  |> maybe_hash_password(opts)
end
```

**Validation Rules**:
1. Email MUST be present
2. Email MUST match format: `[chars]@[chars]` (basic validation)
3. Email MUST be unique across all users
4. Email MUST be ≤ 160 characters
5. Password MUST be present (virtual field)
6. Password MUST be ≥ 12 characters
7. Password MUST be ≤ 72 characters (bcrypt limitation)
8. Password is hashed before storage (using bcrypt or pbkdf2)

**State Transitions**:
```
[Registered, Unconfirmed] ──(confirm email)──> [Registered, Confirmed]
   confirmed_at: nil                              confirmed_at: <timestamp>
```

**Security Notes**:
- Password never stored in plaintext
- Hashed password uses bcrypt (Unix) or pbkdf2 (Windows) with secure work factors
- Email confirmations use separate token system (not stored on User)

---

### UserToken

**Purpose**: Represents authentication tokens for sessions, email confirmations, and password resets.

**Schema**: `ReviewRoom.Accounts.UserToken`

**Table**: `users_tokens`

**Fields**:

| Field | Type | Constraints | Description |
|-------|------|-------------|-------------|
| `id` | `:binary_id` (UUID) | Primary key | Unique token record identifier |
| `user_id` | `:binary_id` (UUID) | Foreign key to `users.id`, NOT NULL | User this token belongs to |
| `token` | `:binary` | NOT NULL | Hashed token value (never store plaintext) |
| `context` | `:string` | NOT NULL | Token purpose: "session", "confirm", "reset_password" |
| `sent_to` | `:string` | NULL allowed | Email address token was sent to (audit trail) |
| `inserted_at` | `:naive_datetime` | NOT NULL, auto | Token creation timestamp |

**Indexes**:
- Index on `user_id` (for querying user's tokens)
- Unique index on `context, token` (prevents duplicate tokens per context)

**Relationships**:
- `belongs_to :user, ReviewRoom.Accounts.User` - The user who owns this token

**Token Contexts**:

| Context | Purpose | Expiration | Single-use? |
|---------|---------|------------|-------------|
| `"session"` | Login session tracking | 60 days (remembered) or browser close | No (deleted on logout) |
| `"confirm"` | Email confirmation | 1 day | Yes (deleted after use) |
| `"reset_password"` | Password reset | 1 day | Yes (deleted after use) |

**Validation Rules**:
1. Token MUST be present
2. Context MUST be present
3. Context MUST be one of: "session", "confirm", "reset_password"
4. Token is hashed before storage (secure random bytes)
5. `user_id` MUST reference existing user

**Token Generation**:
```elixir
# Generate secure random token
token = :crypto.strong_rand_bytes(32)

# Hash token before storage
hashed_token = :crypto.hash(:sha256, token)

# Store hashed version in database
%UserToken{
  user_id: user.id,
  token: hashed_token,
  context: "session",
  sent_to: user.email
}
```

**Token Validation**:
```elixir
# Hash provided token
hashed_token = :crypto.hash(:sha256, provided_token)

# Query database for match
query = from t in UserToken,
  where: t.token == ^hashed_token,
  where: t.context == ^context

# Check expiration based on context
case context do
  "session" -> within_60_days(token.inserted_at)
  "confirm" -> within_1_day(token.inserted_at)
  "reset_password" -> within_1_day(token.inserted_at)
end
```

**Security Notes**:
- Tokens are cryptographically random (32 bytes)
- Tokens are hashed before database storage
- Tokens are single-use for sensitive operations (confirm, reset)
- Expired tokens automatically ignored during validation

---

## Database Migration

**Generated Migration**: `priv/repo/migrations/*_create_users_auth_tables.exs`

```elixir
defmodule ReviewRoom.Repo.Migrations.CreateUsersAuthTables do
  use Ecto.Migration

  def change do
    # Enable UUID extension if not already enabled
    execute "CREATE EXTENSION IF NOT EXISTS citext", ""

    # Create users table
    create table(:users, primary_key: false) do
      add :id, :binary_id, primary_key: true
      add :email, :citext, null: false
      add :hashed_password, :string, null: false
      add :confirmed_at, :naive_datetime

      timestamps()
    end

    create unique_index(:users, [:email])

    # Create users_tokens table
    create table(:users_tokens, primary_key: false) do
      add :id, :binary_id, primary_key: true
      add :user_id, references(:users, type: :binary_id, on_delete: :delete_all), null: false
      add :token, :binary, null: false
      add :context, :string, null: false
      add :sent_to, :string

      timestamps(updated_at: false)
    end

    create index(:users_tokens, [:user_id])
    create unique_index(:users_tokens, [:context, :token])
  end
end
```

**Key Migration Details**:
- Uses `citext` extension for case-insensitive email matching
- `binary_id` for UUID primary keys (project uses `--binary-id` flag)
- `on_delete: :delete_all` ensures tokens deleted when user deleted (cascade)
- Unique constraint on email at database level
- Unique constraint on `(context, token)` prevents duplicate tokens

---

## Context Module Functions

**Module**: `ReviewRoom.Accounts`

**Key Functions** (generated by phx.gen.auth):

### User Management
```elixir
# User registration
register_user(attrs) :: {:ok, User.t()} | {:error, Ecto.Changeset.t()}

# Get user by email (login lookup)
get_user_by_email(email) :: User.t() | nil

# Get user by email and password (authentication)
get_user_by_email_and_password(email, password) :: User.t() | nil

# Update user email
update_user_email(user, token) :: {:ok, User.t()} | {:error, atom()}

# Update user password
update_user_password(user, password, attrs) :: {:ok, User.t()} | {:error, Ecto.Changeset.t()}
```

### Email Confirmation
```elixir
# Deliver confirmation instructions
deliver_user_confirmation_instructions(user, confirmation_url_fun) :: {:ok, %{}}

# Confirm user from token
confirm_user(token) :: {:ok, User.t()} | :error
```

### Password Reset
```elixir
# Deliver password reset instructions
deliver_user_reset_password_instructions(user, reset_url_fun) :: {:ok, %{}}

# Get user by reset token
get_user_by_reset_password_token(token) :: User.t() | nil

# Reset user password
reset_user_password(user, attrs) :: {:ok, User.t()} | {:error, Ecto.Changeset.t()}
```

### Session Management
```elixir
# Generate session token
generate_user_session_token(user) :: binary()

# Get user by session token
get_user_by_session_token(token) :: User.t() | nil

# Delete session token
delete_session_token(token) :: :ok

# Delete all user tokens (logout everywhere)
delete_user_session_token(user) :: :ok
```

---

## Query Patterns

### Common Queries

**Find confirmed user by email:**
```elixir
from u in User,
  where: u.email == ^email,
  where: not is_nil(u.confirmed_at)
```

**Get all active sessions for user:**
```elixir
from t in UserToken,
  where: t.user_id == ^user_id,
  where: t.context == "session",
  where: t.inserted_at > ago(60, "day")
```

**Delete expired tokens:**
```elixir
from t in UserToken,
  where: t.context in ["confirm", "reset_password"],
  where: t.inserted_at < ago(1, "day")
```

---

## Testing Fixtures

**Module**: `ReviewRoom.AccountsFixtures`

**Generated Helpers**:

```elixir
# Create unconfirmed user with random email
user_fixture(attrs \\ %{}) :: User.t()

# Create confirmed user
confirmed_user_fixture(attrs \\ %{}) :: User.t()

# Extract token from email content
extract_user_token(fun) :: binary()

# Generate unique email
unique_user_email() :: String.t()

# Generate valid password
valid_user_password() :: String.t()
```

**Usage in Tests**:
```elixir
# Create test user
user = user_fixture()

# Create confirmed user with custom email
confirmed_user = confirmed_user_fixture(%{email: "test@example.com"})

# Extract confirmation token
token = extract_user_token(fn url ->
  Accounts.deliver_user_confirmation_instructions(user, url)
end)
```

---

## Summary

**Entities**: 2 (User, UserToken)
**Tables**: 2 (users, users_tokens)
**Relationships**: 1 (User has_many UserTokens)
**Indexes**: 3 (users.email unique, users_tokens.user_id, users_tokens.[context,token] unique)
**Validations**: Email format/uniqueness, Password length (12-72 chars)
**Security**: Hashed passwords, hashed tokens, cascade deletes

All entities follow Ecto best practices and will be generated by `mix phx.gen.auth Accounts User users --live`.
